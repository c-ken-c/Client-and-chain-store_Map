<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<title>å®¢æˆ¶ Ã— é€£é–åº— å¯†åº¦åˆ†æ</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
body {
  margin: 0;
  font-family: Arial, "Microsoft JhengHei", sans-serif;
}
.container {
  display: grid;
  grid-template-columns: 420px 1fr;
  height: 100vh;
}
.panel {
  padding: 10px;
  overflow-y: auto;
  border-right: 1px solid #ccc;
}
textarea, input, button {
  width: 100%;
  margin-bottom: 6px;
  padding: 6px;
  font-size: 14px;
}
button {
  cursor: pointer;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
}
button:hover { background: #0056b3; }
#map { height: 100%; }

.ok { color: green; }
.fail { color: #888; font-size: 13px; }
.small { font-size: 12px; color: #1e90ff; margin-left: 8px; }
hr { margin: 10px 0; }
</style>
</head>

<body>
<div class="container">

<div class="panel">

<h2>ğŸ“ å®¢æˆ¶åœ°å€ï¼ˆä¸€è¡Œä¸€ç­†ï¼‰ï½œåœ–ä¾‹ï¼šè—è‰²åœ“åœˆ</h2>
<textarea id="customerInput" rows="8"></textarea>

<h2>ğŸª é€£é–åº—åœ°å€ï¼ˆä¸€è¡Œä¸€ç­†ï¼‰ï½œåœ–ä¾‹ï¼šç´…è‰²åœ“åœˆ</h2>
<textarea id="storeAddrInput" rows="6"></textarea>

<h2>ğŸª é€£é–åº—é—œéµå­—ï½œåœ–ä¾‹ï¼šç¶ è‰²åœ“åœˆ</h2>
<input id="keywordInput" placeholder="ä¾‹å¦‚ï¼šæŒ¯å®‡äº”é‡‘ã€7-11ï¼ˆå¯ç•™ç©ºï¼‰" />

<button onclick="runAnalysis()">ğŸ” åŸ·è¡Œåˆ†æ</button>

<hr>

<h2>ğŸ§¾ å®¢æˆ¶åœ°å€ Geocoding</h2>
<div id="customerLog"></div>

<hr>

<h2>ğŸª é€£é–åº—æœå°‹</h2>
<div id="storeLog"></div>

</div>

<div id="map"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
const map = L.map("map").setView([23.7, 121], 7);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "Â© OpenStreetMap"
}).addTo(map);

const customerLayer = L.layerGroup().addTo(map);
const storeLayer = L.layerGroup().addTo(map);

const sleep = ms => new Promise(r => setTimeout(r, ms));
const cleanAddress = l => l.includes("ï¼š") ? l.split("ï¼š")[1].trim() : l.trim();

async function runAnalysis() {
  customerLayer.clearLayers();
  storeLayer.clearLayers();
  customerLog.innerHTML = "";
  storeLog.innerHTML = "";

  await geocodeList(customerInput.value, "customer");
  await geocodeList(storeAddrInput.value, "storeAddr");
  await searchByKeyword();
  fitAll();
}

async function geocodeList(text, type) {
  const lines = text.split("\n").filter(l => l.trim());
  for (const line of lines) {
    const addr = cleanAddress(line) + " å°ç£";
    const url = "https://nominatim.openstreetmap.org/search?" +
      new URLSearchParams({ q: addr, format: "json", limit: 1, countrycodes: "tw" });

    const res = await fetch(url);
    const data = await res.json();

    if (data.length) {
      const lat = +data[0].lat;
      const lon = +data[0].lon;

      drawPoint(lat, lon, type, line);
      log(type === "customer" ? customerLog : storeLog,
          `âœ” ${line}<span class="small">âœ ${addr}</span>`, true);
    } else {
      log(type === "customer" ? customerLog : storeLog,
          `âœ– ${line}`, false);
    }
    await sleep(900);
  }
}

function drawPoint(lat, lon, type, label) {
  const cfg = {
    customer: { c:"#1e90ff", fill:"#1e90ff" },
    storeAddr:{ c:"#d93025", fill:"#d93025" },
    keyword:{ c:"#188038", fill:"#188038" }
  }[type];

  L.circleMarker([lat, lon], {
    radius: 4,
    color: cfg.c,
    fillColor: cfg.fill,
    fillOpacity: 1
  }).bindPopup(label).addTo(type==="customer"?customerLayer:storeLayer);

  L.circle([lat, lon], {
    radius: 3000,
    color: cfg.c,
    fillColor: cfg.fill,
    fillOpacity: 0.15,
    weight: 1
  }).addTo(type==="customer"?customerLayer:storeLayer);
}

async function searchByKeyword() {
  const keyword = keywordInput.value.trim();
  if (!keyword) return;

  const query = `[out:json][timeout:25];
(
 node["name"~"${keyword}",i](21.8,120,25.4,122.1);
 way["name"~"${keyword}",i](21.8,120,25.4,122.1);
);
out center;`;

  const res = await fetch("https://overpass-api.de/api/interpreter", {
    method:"POST", body:query
  });
  const data = await res.json();

  data.elements?.forEach(el => {
    const lat = el.lat || el.center.lat;
    const lon = el.lon || el.center.lon;
    drawPoint(lat, lon, "keyword", el.tags.name);
    storeLog.innerHTML += `<div class="ok">âœ” ${el.tags.name}</div>`;
  });
}

function fitAll() {
  const pts = [];
  customerLayer.eachLayer(l => l.getLatLng && pts.push(l.getLatLng()));
  storeLayer.eachLayer(l => l.getLatLng && pts.push(l.getLatLng()));
  if (pts.length) map.fitBounds(pts, { padding:[50,50], maxZoom:12 });
}

function log(el, text, ok) {
  const d = document.createElement("div");
  d.className = ok ? "ok" : "fail";
  d.innerHTML = text;
  el.appendChild(d);
}
</script>
</body>
</html>
